В папку components можно добавлять вспомогательные классы

htmlOptions - параметр во многих классах, который представляет собой массив ,содержащий в себе html параметры, это к примеру
class html-элемента и т.д.

cssClassExpression - задает класс по условию 'cssClassExpression' => '($data->id < 5) ? "my" : "my1" '
(т.к в dataProvider мы писали $model, то к переменным модели теперь надо обращаться через переменную $data)


функция relations в какой-либо модели отвечает за построение отношений между моделями.Установим связь между
таблицами page и gategory
self::BELONGS_TO - означает "пренадлежит к", вторым параметром указывает,то к чему принадлежит,т.е Page принадлежит к модели
Category, по полю указаному 3 параметром, т.е category_id

public function relations()
	{
		return array(
		    'category' => array(self::BELONGS_TO,'Category','category_id')
		);
	}

потом в файле представления,т.е из папки View , мы должны указать вывод связаных данных,т.е в представлении Page
 мы можем получить данные из Category, пример $data->category->title, т.е. мы обратились к данным Page,извлекли данные по
 полю category,его мы передали через массив  в функции relations(), тем самым мы получили запись из таблицы category и можем
 обращаться к люблму столбцу этой записи.


$this->redirect(Yii::app()->user->returnUrl); -  перебрасывает пользователя на страницу ,на которой он был ранее(можно
использовать при авторизации пользователя,т.е если он зашел на страницу неавторизованым, и потом авторизовался,то
потом можно его перебросить на ту же страницу,на которой он был.)


if(Yii::app()->user->hasFlash('contact')) - проверяет, хранится ли сообщение с идентификатором contact
Yii::app()->user->setFlash('contact','Удачная отправка письма'); - устанавливает сообщение с идентификатором contact
Yii::app()->user->getFlash('contact'); получает сообщение с идентификатором contact

/* class CActiveRecord - основной класс для работы с бд
    Функции:
         * save - сохраняент значения в таблицу,пример
         *  $model->title = 'bgrwer';
         *  $model->author = 'jynesb';
         *  $model->year = 1954;
         *  $model->save(false);
         *  Чтобы записывать данные в таблицу по циклу необходимо сбросить первичный ключ $model->id = false
         *  и указать,что создается новая запись $model->isNewRecord = true;
         * findByPk - поиск по ключу(в таблице i_book это было поле id)
         *
         * findAllByPk - поиск по массиву ключей
         *
         * find - выполняет поиск, в скобках задается условие (к примеру id<3) и передаваемые параметры( общий пример того,
         * что в скобках find('id < :num',array(':num' => $num)) - вернет первую найденную запись
         *
         * findAll - тоже что и find , но вернет все записи,удовлетворяющие условию
         *
         * count - возвращает количество записей,удовлетворяющих условию count('id < :num',array(':num' => $num))
         *
         * findByAttribytes - поиск по переданным атрибутам(полям),
         * пример findByAttribytes(array('id' => array(1,2,5), 'title' => 'Война и мир' )) - выдает первую найденную запись
         *
         * findAllByAttribytes - как и findByAttribytes, но выбирает все записи
         *
         * findBySql - поиск по sql запросу,выводит первую запись
         *
         * findAllBySql - поиск по sql запросу,выводит все записи
         *
         * countBySql - возвращает количество записей,удовлетворяющих sql запросу
         *
         * exists - возвращает по условию ('id < :num',array(':num' => $num) true или false,т.е существует запись или нет
         *
         * updateByPk - обновление полей по ключу,в скобках задаются ключ или массив ключей,
         * второй параметр - это массив полей с новыми значениями,пример updateByPk($i,array('year'=>$year++))
         *
         * updateAll - обновляет поля по условию, условие идет вторым параметром
         * ,третий параметр - это массив параметров
         * первый параметр - это массив обновляемых полей,
         * пример updateAll(array('author' => 'Толкиен'),'author = :author',array(':author' => 'Толстой'))
         *
         * deleteAll и deleteByPk - работаю по принципу updateByPk и updateAll
         * пример deleteByPk(1);   deleteAll('title = :title',array(':title' => 'Толстой'));
*/

/*
    * $this->render('index'); - можно передавать как один,так и два параметра: первый параметр - это на какой файл в папке view
    * надо перейти,во второй параметр можно засунуть данные,которые необходимо передать в этот файл в папке view
    * (можно передать массив и брать данные по ассоциативным именам элементов этогоо массива).Третий параметр позволяет
    * засунуть представление в переменную если задать этот параметр как true,по умолчанию он стоит как false.
    * Пример  $this->render('index',array('result' => $mas)); потом можно получать данные во view через переменную в
    * данном случает $result;
    *
    * rederPartial - отличается от render тем,что загружает лишь небольшок кусок кода из файла указанного в параметре
    * и вставляет его в файл из которого этот метод был вызван,т.е. его следует вызывать во view.
    *
    *
    *
    *
    *
    *
*/

/*CHtml - класс отвечающий за прорисовку html элементов(много функций по прорисовке)
    * Пример работы с link:
    * foreach($result as $res){
    *     echo CHtml::link(CHtml::encode($res->title),array('page/view','id' => $res->id));
    * } - первый параметр текст ссылки,второй параметр путь(массив,в который можно дополнительно включать
    * дополнения к пути,в результате получится что-то типа http://localhost/yii/index.php/page/1
    *
    *
    *
    *
*/

    * accessRules() - в функции определяется каким пользователям, какие действия разрешены
    * validator - проверяет данные,правила проверки данных определены в модели в функции rules(),пример
    * array('title, text', 'required') или
    * array('title', 'compare', 'compareAttribute' => 'text','message' => 'Поля title и text не равны'),
    * в первом поле перечисляются поля для валидации, во втором поле пишется валидатор,список валидаторов и его параметров
    * можно найти на сайте фреймворка
    * Создание своего валидатора:
    * В модели пишем функцию c любым именем
    * protected function valid($attributes,$params) {
    *   $a = $this->$attributes; //записывает переданные в функцию атрибуты
    *   if( a != 1){ //задаем какое-то условие проверки переданых аттрибутов
    *       $this->addError($attributes,'Ошибка');
    *   }
    * }
    * , а затем используем имя нашего валидатора в функции rules()
    *   array('title, text', 'valid')
    *
    * В контроллерах у каждого действия action можно задать сценарий $model->scenario = 'какой-то сценарий'
    * и при валидации указать одним из параметров 'on' => 'какой-то сценарий', т.е валидация будет выполняться
    * только для этого сценария.
    *
    *
*/

/* CMenu - класс я построения меню с помощью различных виджетов,описание и передаваемые параметры описаны в документации
    * вызывается через zii.widgets , затем пишется вызываемый класс.
    * можно и так $this->breadcrumbs = array('Controller' => array('index')); ,где 'Controller' - это название ссылки, а
    * array('index') это то,куда перейдем ,если кликнуть по этой ссылке.
    *
    * если задавать $this->breadcrumbs = array('Controller' => array('index'));, то ссылки выведутся по стандарту после меню,
    * а если задавать $this->widget('zii.widgets.CBreadcrumbs',array('links' => array('Controller' => array('index.php'),'My')));
    * то ссылки выведутся там,где мы их написали, т.е. их можно выводить в любом удобном для нас месте.
    *
    *
    *
    *

*/

/*CDetailView - класс используется для вывода данных в виде таблицы
    *пример $this->widget('zii.widgets.CDetailView', array('data' => $model , 'attributes' => array('id','title','text')));
    * 'data' это данные передаваемые в этот класс, а 'attributes' - это поля,которые необходимо вывести
    * все эти данные выводятся в  виде таблицы. $model соответственно это данные передаваемые через контроллер в функции render
    *
    *
    *
    *
    *
    *
    *

*/

/*CListView
    * this->widget('zii.widgets.CListView',array('dataProvider' => $dataProvider,'itemView' => '_view','sortableAttributes' => array('title')));
    * вторым параметром передается массив,состоящий из 'dataProvider', туда записывается особый тип данных CActiveDataProvider
    * который определяется в контроллере, CActiveDataProvider это класс,т.е. создается new CActiveDataProvider
    * и 'itemView', куда передается шаблон,который надо отображать, он вставляет этот шаблон в страницу из которой был вызван
    * виджет.
    * 'sortableAttributes' => array('title') отображает на сайте элемент,с помощью которого можно управлять сортировкой
    * (по убыванию или возрастанию)
    * 'sorterHeader' => 'Сортировать по' - это attributeLabel для элемента сортировки(текст,который выведется рядом)
    * 'summaryText' => 'Выводится {start} - {end} из {count}' в итоге выведется например 'Выводится 1-3 из 3'
    *
    *
    *


*/

/*CActiveDataProvider особый файл,который первым параметром принимает модель,а вторым параметры.
    * $dataProvider = new CActiveDataProvider('Page');
    * $dataProvider = new CActiveDataProvider('Page',array('criteria' => $criteria)), где $criteria
    * это какое то условие,например $criteria = new CDbCriteria; $criteria->condition = 'id = 5';
    * можно задать разбивку виджета на страницу, если в массив во втором параметре добавить запись
    * 'pagination' => array('pageSize' => 1); в итоге у нас на странице появится pager,возможность листать по страницам
    * и теперь по одной записи на странице,если задать этот параметр 2,то по 2 записи на странице
    *
    *

*/

/* CGridView - класс предназначенный для создания табличного представления данных,пример Pages-Manage
    * $this->widget('zii.widgets.grid.CGridView', array(
      	'id'=>'page-grid',  - идентификатор столбцов,к ним будут добавляться ещё буквы в процессе работы
      	'dataProvider'=>$model->search(), вызывается метод search() из $model,где $model это данные переданные из контроллера
      	из метода actionAdmin(), search() - это метод,который находится в нашей модели,он возвращает CActiveDataProvider
      	'filter'=>$model,
      	'columns'=>array(
      		'id',
      		'title',
      		'text',
      		array(
      			'class'=>'CButtonColumn',
      		),
      	),
      ));
    *
    *
    *
    *
    *
    *
*/

/*CSort  - класс предназначенный для сортировки
    *
    *
    *

*/
/*
    *CButtonColumn - отвечает за отображение кнопок типа удалить,посмотреть,редактировать и прочее
    *CGridColumn - используется для настройки колонок,а не всей таблицы как CGridView
    *CCheckBoxColumn - используется для добавления в таблицу столбца с checkbox для каждой записи
*/

/*
    *CController - базовый класс для контроллеров
    * функция redirect перенаправляет на другую страницу , пример использования
    * $this->redirect(array('view','id'=>$model->id)); или  $this->redirect(array('site/index')); - первый параметр
    * это какой-то action( actionIndex,actionCreate и т.д.), 'site/index' означает,что надо вызвать из контроллера SiteController
    * функцию actionIndex
    *

*/

/*CDbCommand, CDbConnection - классы используются для работы с базой данных,но запросы уже можно составлять вручную.
    *Пример работы :
    * 1. Устанавливаем соединение $connect = Yii::app()->db;
    * 2. Составляем запрос sql и засовываем его в команду $command = $connect->createCommand($sql);
    * 3. Выполняем запрос,это можно сделать двуме методами
    *   $command->execute(); //для UPDATE,DELETE,INSERT, для тех команд которые не возвращают результатов
    * // команда возвращает только true или false
    *   $command->query(); //для SELECT ,так же существует несколько разновидностей query ,
    * это queryAll -  выбрать все записи,queryRow - выбрать первую запись и т.д.
    *
*/